/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "places.h"
#include "airports.h"

const nametype FILE_NAME = "places2k.txt";
const int stateAbbreviationLength = 2;
const int NUMBER_OF_STATES = 52;

const int BAD_STATE = -1;
const int UNCLEAR = -2;
const int UNKNOWN = -3;


void initializeData();
void lowerCase(char *x);
int getCoordinates(place *pair, geoLocation *coord);
void freeData();

nearest_results_place *
getnearest_place_1_svc(place *argp, struct svc_req *rqstp)
{
  static nearest_results_place result;
  result.err = 0;

	//If state not 2 characters
	if(strlen(argp->state) != 2){
		result.err = EAGAIN;
		perror("Invalid state.\n");
	}

	xdr_free((xdrproc_t)xdr_nearest_results_place, (char*)&result);

	lowerCase(argp->city);
	lowerCase(argp->state);

	printf("Received city: %s\n", argp->city);
	printf("Received state: %s\n\n",argp->state);

	CLIENT *clnt;
	nearest_results_air  *result_1;
	geoLocation getnearest_air_1_arg;
	int num;
	

	num = getCoordinates(argp, &getnearest_air_1_arg);
	if(num == 0){

	  printf("Lat: %f, Long: %f\n\n", getnearest_air_1_arg.latitude,getnearest_air_1_arg.longitude);
	} else if (num == BAD_STATE) {
	  result.err = BAD_STATE;
	  perror("Not a state.\n");
	  return (&result);

	} else if (num == UNCLEAR){
	  result.err = UNCLEAR;
	  perror("More specific city needed.\n");
	  return (&result);

	} else {
	  result.err = UNKNOWN;
	  perror("Non existent city.\n");
	  return (&result);
	}


// Touch on this later
#ifndef DEBUG
	clnt = clnt_create ("localhost", airportProgram, airport_version, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror ("localhost");
		exit (1);
	}
#endif 

	result_1 = getnearest_air_1(&getnearest_air_1_arg, clnt);
	if (result_1 == (nearest_results_air *) NULL) {
		clnt_perror (clnt, "call failed");
	} else{
		if (result_1->err == 0){
			printf("Print result: \n");
			result.nearest_results_place_u.x = result_1->nearest_results_air_u.x;

			airList_air walker = result_1->nearest_results_air_u.x;
			while(walker != NULL)
			{
				printf("Code: %s\n", walker->p.code);
				printf("Name: %s\n", walker->p.name);
				printf("Distance: %f\n", walker->p.dist);
				printf("Longitude: %f\n", walker->p.loc.longitude);
				printf("Latitude: %f\n", walker->p.loc.latitude);
				walker = walker->next;
			}
		}
	}



	return &result;

}

void lowerCase(char *x)
{
	int i = 0;
	for(i; i < strlen(x);i++)
		x[i] = tolower(x[i]);
}

void initializeData()
{
	FILE * fp = NULL;

	nametype previousState;
	previousState = malloc(MAXLEN);
	strcpy(previousState, "00");

	nametype currentState;
	currentState = malloc(MAXLEN);

	nametype line;
	line = malloc(MAXLEN);

	nametype latitude;
	latitude = malloc(MAXLEN);
	nametype longitude;
	longitude = malloc(MAXLEN);

	int stateIndex = -1;
	int cityOrTownIndex;


	CityOrTown *currentStatePointer;

	printf("Opening file: places2k.txt \n");
	fp = fopen(FILE_NAME, "r");

	
	while(fgets(line, MAXLEN, fp) != NULL)
	{
		strncpy(currentState,line,2);
		if(strcmp(previousState, currentState) != 0)
		{
			// Update condition
			strcpy(previousState,currentState);
			stateIndex++;

			// Initialize the state
			listOfState[stateIndex].stateAbbreviation = malloc(2);
			strncpy(listOfState[stateIndex].stateAbbreviation,line,2);
			lowerCase(listOfState[stateIndex].stateAbbreviation);

			cityOrTownIndex = listOfState[stateIndex].numberOfCityOrTown = 1;

			// Add a city or town
			currentStatePointer = listOfCityOrTownByState[stateIndex];
			currentStatePointer[cityOrTownIndex-1].cityOrTownName = malloc(MAXLEN);

			//line is a pointer + 9 to move to the next 10 char, if you can find a better way to do this, do it
			//cuz this is rediculously stupid
			strncpy(currentStatePointer[cityOrTownIndex-1].cityOrTownName, line + 9, 63);
			lowerCase(currentStatePointer[cityOrTownIndex-1].cityOrTownName);
			
			strncpy(latitude, line+(144), 9);
			strncpy(longitude, line+(154), 9);
			currentStatePointer[cityOrTownIndex-1].latitude = strtod(latitude, NULL);
			currentStatePointer[cityOrTownIndex-1].longitude = strtod(longitude, NULL);

		}
		else
		{
			cityOrTownIndex = ++listOfState[stateIndex].numberOfCityOrTown;

			// Add a city or town
			currentStatePointer = listOfCityOrTownByState[stateIndex];
			currentStatePointer[cityOrTownIndex-1].cityOrTownName = malloc(MAXLEN);

			strncpy(currentStatePointer[cityOrTownIndex-1].cityOrTownName, line + 9, 63);
			lowerCase(currentStatePointer[cityOrTownIndex-1].cityOrTownName);

			strncpy(latitude, line+(144), 9);
			strncpy(longitude, line+(154), 9);
			currentStatePointer[cityOrTownIndex-1].latitude = strtod(latitude, NULL);
			currentStatePointer[cityOrTownIndex-1].longitude = strtod(longitude, NULL);
		}
	}
}



  int getCoordinates(place *pair, geoLocation *coord)
{
      
  int index = 0; //For State
  

  //Find state index
  while(index < NUMBER_OF_STATES && strcmp(pair->state,listOfState[index].stateAbbreviation) != 0)
	index++;
  
  //bad state return something bad
  if(index >= NUMBER_OF_STATES)
	return BAD_STATE;

  int size = listOfState[index].numberOfCityOrTown;
  int low = 0; //For Binary Search
  int high = size-1;
  int mid;
  int found = 0;

  int length = strlen(pair->city);
  
  //Binary Search
  while (found == 0 && low <= high){
	mid = (high + low)/2;
	if(strncmp((listOfCityOrTownByState[index][mid].cityOrTownName),(pair->city),
			   length) == 0){
	  found = 1;
	}else if (strncmp((listOfCityOrTownByState[index][mid].cityOrTownName),(pair->city),
					  length) > 0){
	  high = mid - 1;
	}else{
	  low = mid + 1;
	}
  }

  
  //Check immediate city above and below to see if we have same prefix
  if(found == 1){
	//check above
	if(mid+1<size)
	  if(strncmp((listOfCityOrTownByState[index][mid+1].cityOrTownName),
			   (pair->city),length) == 0)
		return UNCLEAR;

	//check below
	if(mid-1>0)
	  if(strncmp((listOfCityOrTownByState[index][mid-1].cityOrTownName),
			    (pair->city),length) == 0)
		return UNCLEAR;

	coord->longitude = listOfCityOrTownByState[index][mid].longitude;
	coord->latitude = listOfCityOrTownByState[index][mid].latitude;

	printf("City: %s\n",listOfCityOrTownByState[index][mid].cityOrTownName);
	printf("State: %s\n",listOfState[index].stateAbbreviation);
	return 0;
  }

  //Not found
  return UNKNOWN;

  
}


void freeData()
{
	int i = 0;
	int size;

	//All States
	for(i; i < NUMBER_OF_STATES; i++){
		size = listOfState[i].numberOfCityOrTown;
		if(size > 0){
			int s = 0;

			//All cities for each state
			for(s; s < size; s++){
				free(listOfCityOrTownByState[i][s].cityOrTownName);
			}

			free(listOfState[i].stateAbbreviation);
			free(listOfState[i].stateName);
		}
	}

}



char * getStateName(int index)
{
	return NULL;
}

/*
 int i,j;
 for(i = 0; i < 52; i++)
 {
 	printf("%s:------------------------\n", listOfState[i].stateAbbreviation);
 	for(j = 0; j < listOfState[i].numberOfCityOrTown; j++)
 	{
 		printf("%s\n", listOfCityOrTownByState[i][j].cityOrTownName);
 	}
 }
*/
