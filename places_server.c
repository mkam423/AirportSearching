/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "places.h"
#include "airports.h"

const nametype FILE_NAME = "places2k.txt";
const int stateAbbreviationLength = 2;
const int NUMBER_OF_STATES = 52;

const int BAD_STATE = -1;
const int UNCLEAR = -2;
const int UNKNOWN = -3;

void initializeData();
void lowerCase(char *x);
int getCoordinates(place *pair, geoLocation *coord,place *actual);
void freeData();

nearest_results_place *
getnearest_place_1_svc(place *argp, struct svc_req *rqstp)
{
	static nearest_results_place result;
	result.err = 1;
	result.nearest_results_place_u.info.x = NULL;

	//If state not 2 characters
	if(strlen(argp->state) != 2){
		result.err = BAD_STATE;
		perror("Invalid state.\n");
	}

	//Free Memory
	xdr_free((xdrproc_t)xdr_nearest_results_place, (char*)&result);

	//Case-insensitive everything
	lowerCase(argp->city);
	lowerCase(argp->state);

	//Set up airport client
	CLIENT *clnt;
	nearest_results_air *result_1;
	geoLocation getnearest_air_1_arg; //arg for airport server
	int num; //Holds result of function
	place found; //Holds actual place
	

	num = getCoordinates(argp, &getnearest_air_1_arg, &found);

	//Check if any problems
	if (num == BAD_STATE) {
	  result.err = BAD_STATE;
	  perror("Not a state.\n");
	  return (&result);

	} else if (num == UNCLEAR){
	  result.err = UNCLEAR;
	  perror("More specific city needed.\n");
	  return (&result);

	} else if (num == UNKNOWN){
	  result.err = UNKNOWN;
	  perror("Non existent city.\n");
	  return (&result);
	}


#ifndef DEBUG
	clnt = clnt_create ("localhost", airportProgram, airport_version, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror ("localhost");
		exit (1);
	}
#endif 

	result_1 = getnearest_air_1(&getnearest_air_1_arg, clnt);
	if (result_1 == (nearest_results_air *) NULL) {
		clnt_perror (clnt, "call failed");
	} else{
		//Copy all the data to be returned
		if (result_1->err == 0){
			result.err = 0;
			result.nearest_results_place_u.info.search_location = found;
			result.nearest_results_place_u.info.coord.latitude = getnearest_air_1_arg.latitude;
			result.nearest_results_place_u.info.coord.longitude = getnearest_air_1_arg.longitude;
			result.nearest_results_place_u.info.x = (airList_place)result_1->nearest_results_air_u.x;
			
			//Free of result_1 is in client after reading 
		}
	}
	
	return &result;
}

void lowerCase(char *x)
{
	int i = 0;
	for(i; i < strlen(x);i++)
		x[i] = tolower(x[i]);
}

//Memory for Data structure is free in the places_svc.c main
//Below defines freedata() function that does the work
void initializeData()
{
	FILE * fp = NULL;


	nametype previousState;
	previousState = malloc(MAXLEN);
	strcpy(previousState, "00");

	nametype currentState;
	currentState = malloc(MAXLEN);

	nametype line;
	line = malloc(MAXLEN);

	nametype latitude;
	latitude = malloc(MAXLEN);
	nametype longitude;
	longitude = malloc(MAXLEN);

	int stateIndex = -1;
	int cityOrTownIndex;

	CityOrTown *currentStatePointer;

	fp = fopen(FILE_NAME, "r");

	
	while(fgets(line, MAXLEN, fp) != NULL)
	{
		strncpy(currentState,line,2);
		if(strcmp(previousState, currentState) != 0)
		{
			// Update condition
			strcpy(previousState,currentState);
			stateIndex++;

			// Initialize the state
			listOfState[stateIndex].stateAbbreviation = malloc(2);
			strncpy(listOfState[stateIndex].stateAbbreviation,line,2);
			lowerCase(listOfState[stateIndex].stateAbbreviation);

			cityOrTownIndex = listOfState[stateIndex].numberOfCityOrTown = 1;

			// Add a city or town
			currentStatePointer = listOfCityOrTownByState[stateIndex];
			currentStatePointer[cityOrTownIndex-1].cityOrTownName = malloc(MAXLEN);

			//line is a pointer + 9 to move to the next 10 char
			strncpy(currentStatePointer[cityOrTownIndex-1].cityOrTownName, line + 9, 63);
			lowerCase(currentStatePointer[cityOrTownIndex-1].cityOrTownName);
			
			strncpy(latitude, line+(143), 9);
			strncpy(longitude, line+(153), 9);
			currentStatePointer[cityOrTownIndex-1].latitude = strtod(latitude, NULL);
			currentStatePointer[cityOrTownIndex-1].longitude = strtod(longitude, NULL);

		}
		else
		{
			//+1 city
			cityOrTownIndex = ++listOfState[stateIndex].numberOfCityOrTown;

			// Add a city or town
			currentStatePointer = listOfCityOrTownByState[stateIndex];
			currentStatePointer[cityOrTownIndex-1].cityOrTownName = malloc(MAXLEN);

			//Name
			strncpy(currentStatePointer[cityOrTownIndex-1].cityOrTownName, line + 9, 63);
			lowerCase(currentStatePointer[cityOrTownIndex-1].cityOrTownName);

			//Lat and long copy
			strncpy(latitude, line+(143), 9);
			strncpy(longitude, line+(153), 9);
			currentStatePointer[cityOrTownIndex-1].latitude = strtod(latitude, NULL);
			currentStatePointer[cityOrTownIndex-1].longitude = strtod(longitude, NULL);
		}
	}

	free(previousState);
	free(currentState);
	free(line);
	free(latitude);
	free(longitude);

}

int getCoordinates(place *pair, geoLocation *coord, place *actual)
{
      
  int index = 0; //For State
  

  //Find state index
  while(index < NUMBER_OF_STATES && strcmp(pair->state,listOfState[index].stateAbbreviation) != 0)
	index++;
  
  //bad state return something bad
  if(index >= NUMBER_OF_STATES)
	return BAD_STATE;

  int size = listOfState[index].numberOfCityOrTown;
  int low = 0; //For Binary Search
  int high = size-1;
  int mid;
  int found = 0;

  int length = strlen(pair->city);
  
  //Binary Search
  while (found == 0 && low <= high){
	mid = (high + low)/2;
	if(strncmp((listOfCityOrTownByState[index][mid].cityOrTownName),(pair->city),
			   length) == 0){
	  found = 1;
	}else if (strncmp((listOfCityOrTownByState[index][mid].cityOrTownName),(pair->city),
					  length) > 0){
	  high = mid - 1;
	}else{
	  low = mid + 1;
	}
  }

  
  //Check immediate city above and below to see if we have same prefix
  if(found == 1){
	//check above
	if(mid+1<size)
	  if(strncmp((listOfCityOrTownByState[index][mid+1].cityOrTownName),
			   (pair->city),length) == 0)
		return UNCLEAR;

	//check below
	if(mid-1>0)
	  if(strncmp((listOfCityOrTownByState[index][mid-1].cityOrTownName),
			    (pair->city),length) == 0)
		return UNCLEAR;

	//Copy for Airport Server
	coord->longitude = listOfCityOrTownByState[index][mid].longitude;
	coord->latitude = listOfCityOrTownByState[index][mid].latitude;

	//Copy actual location found for Places Client
	actual->city = strdup(listOfCityOrTownByState[index][mid].cityOrTownName);
	actual->state = strdup(listOfState[index].stateAbbreviation);


	return 0;
  }

  //Not found
  return UNKNOWN;

  
}

//Free is called in places stub main
void freeData()
{
	int i = 0;
	int size;

	//All States
	for(i; i < NUMBER_OF_STATES; i++){
		size = listOfState[i].numberOfCityOrTown;
		if(size > 0){
			int s = 0;

			//All cities for each state
			for(s; s < size; s++){
				free(listOfCityOrTownByState[i][s].cityOrTownName);
			}

			free(listOfState[i].stateAbbreviation);
			free(listOfState[i].stateName);
		}
	}

}

char * getStateName(int index)
{
	return NULL;
}
