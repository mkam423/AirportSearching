/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "places.h"
#include "airports.h"

const nametype FILE_NAME = "places2k.txt";
const int stateAbbreviationLength = 2;
const int NUMBER_OF_STATES = 52;

const int BAD_STATE = -1;
const int UNCLEAR = -2;
const int UNKNOWN = -3;

void initializeData();
void lowerCase(char *x);
int getCoordinates(place *pair, geoLocation *coord);
void freeData();
airList_place copy_node(airList_place head);

nearest_results_place *
getnearest_place_1_svc(place *argp, struct svc_req *rqstp)
{
	static nearest_results_place result;
	result.err = 1;
	result.nearest_results_place_u.x = NULL;

	//If state not 2 characters
	if(strlen(argp->state) != 2){
		result.err = BAD_STATE;
		perror("Invalid state.\n");
	}

	xdr_free((xdrproc_t)xdr_nearest_results_place, (char*)&result);

	lowerCase(argp->city);
	lowerCase(argp->state);

	CLIENT *clnt;
	nearest_results_air  *result_1;
	geoLocation getnearest_air_1_arg;
	int num;
	
	num = getCoordinates(argp, &getnearest_air_1_arg);
	if(num == 0){

	  printf("Lat: %f, Long: %f\n\n", getnearest_air_1_arg.latitude,getnearest_air_1_arg.longitude);
	} else if (num == BAD_STATE) {
	  result.err = BAD_STATE;
	  perror("Not a state.\n");
	  return (&result);

	} else if (num == UNCLEAR){
	  result.err = UNCLEAR;
	  perror("More specific city needed.\n");
	  return (&result);

	} else {
	  result.err = UNKNOWN;
	  perror("Non existent city.\n");
	  return (&result);
	}


// Touch on this later
#ifndef DEBUG
	clnt = clnt_create ("localhost", airportProgram, airport_version, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror ("localhost");
		exit (1);
	}
#endif 

	result_1 = getnearest_air_1(&getnearest_air_1_arg, clnt);
	if (result_1 == (nearest_results_air *) NULL) {
		clnt_perror (clnt, "call failed");
	} else{
		if (result_1->err == 0){
			result.err = 0;
			result.nearest_results_place_u.x = (airList_place)result_1->nearest_results_air_u.x;

		}
	}

	//clnt_freeres (clnt, (xdrproc_t)xdr_nearest_results_air, (char*)result_1);
	return &result;
}

void lowerCase(char *x)
{
	int i = 0;
	for(i; i < strlen(x);i++)
		x[i] = tolower(x[i]);
}

void initializeData()
{
	FILE * fp = NULL;

	nametype previousState;
	previousState = malloc(MAXLEN);
	strcpy(previousState, "00");

	nametype currentState;
	currentState = malloc(MAXLEN);

	nametype line;
	line = malloc(MAXLEN);

	nametype latitude;
	latitude = malloc(MAXLEN);
	nametype longitude;
	longitude = malloc(MAXLEN);

	int stateIndex = -1;
	int cityOrTownIndex;

	CityOrTown *currentStatePointer;

	printf("Opening file: places2k.txt \n");
	fp = fopen(FILE_NAME, "r");

	
	while(fgets(line, MAXLEN, fp) != NULL)
	{
		strncpy(currentState,line,2);
		if(strcmp(previousState, currentState) != 0)
		{
			// Update condition
			strcpy(previousState,currentState);
			stateIndex++;

			// Initialize the state
			listOfState[stateIndex].stateAbbreviation = malloc(2);
			strncpy(listOfState[stateIndex].stateAbbreviation,line,2);
			lowerCase(listOfState[stateIndex].stateAbbreviation);

			cityOrTownIndex = listOfState[stateIndex].numberOfCityOrTown = 1;

			// Add a city or town
			currentStatePointer = listOfCityOrTownByState[stateIndex];
			currentStatePointer[cityOrTownIndex-1].cityOrTownName = malloc(MAXLEN);

			//line is a pointer + 9 to move to the next 10 char
			strncpy(currentStatePointer[cityOrTownIndex-1].cityOrTownName, line + 9, 63);
			lowerCase(currentStatePointer[cityOrTownIndex-1].cityOrTownName);
			
			strncpy(latitude, line+(143), 9);
			strncpy(longitude, line+(153), 9);
			currentStatePointer[cityOrTownIndex-1].latitude = strtod(latitude, NULL);
			currentStatePointer[cityOrTownIndex-1].longitude = strtod(longitude, NULL);

		}
		else
		{
			cityOrTownIndex = ++listOfState[stateIndex].numberOfCityOrTown;

			// Add a city or town
			currentStatePointer = listOfCityOrTownByState[stateIndex];
			currentStatePointer[cityOrTownIndex-1].cityOrTownName = malloc(MAXLEN);

			strncpy(currentStatePointer[cityOrTownIndex-1].cityOrTownName, line + 9, 63);
			lowerCase(currentStatePointer[cityOrTownIndex-1].cityOrTownName);

			strncpy(latitude, line+(143), 9);
			strncpy(longitude, line+(153), 9);
			currentStatePointer[cityOrTownIndex-1].latitude = strtod(latitude, NULL);
			currentStatePointer[cityOrTownIndex-1].longitude = strtod(longitude, NULL);
		}
	}
}

int getCoordinates(place *pair, geoLocation *coord)
{
      
  int index = 0; //For State
  

  //Find state index
  while(index < NUMBER_OF_STATES && strcmp(pair->state,listOfState[index].stateAbbreviation) != 0)
	index++;
  
  //bad state return something bad
  if(index >= NUMBER_OF_STATES)
	return BAD_STATE;

  int size = listOfState[index].numberOfCityOrTown;
  int low = 0; //For Binary Search
  int high = size-1;
  int mid;
  int found = 0;

  int length = strlen(pair->city);
  
  //Binary Search
  while (found == 0 && low <= high){
	mid = (high + low)/2;
	if(strncmp((listOfCityOrTownByState[index][mid].cityOrTownName),(pair->city),
			   length) == 0){
	  found = 1;
	}else if (strncmp((listOfCityOrTownByState[index][mid].cityOrTownName),(pair->city),
					  length) > 0){
	  high = mid - 1;
	}else{
	  low = mid + 1;
	}
  }

  
  //Check immediate city above and below to see if we have same prefix
  if(found == 1){
	//check above
	if(mid+1<size)
	  if(strncmp((listOfCityOrTownByState[index][mid+1].cityOrTownName),
			   (pair->city),length) == 0)
		return UNCLEAR;

	//check below
	if(mid-1>0)
	  if(strncmp((listOfCityOrTownByState[index][mid-1].cityOrTownName),
			    (pair->city),length) == 0)
		return UNCLEAR;

	coord->longitude = listOfCityOrTownByState[index][mid].longitude;
	coord->latitude = listOfCityOrTownByState[index][mid].latitude;
	pair->city = strdup(listOfCityOrTownByState[index][mid].cityOrTownName);
	pair->state = strdup(listOfState[index].stateAbbreviation);

	printf("City: %s\n",listOfCityOrTownByState[index][mid].cityOrTownName);
	printf("State: %s\n",listOfState[index].stateAbbreviation);
	return 0;
  }

  //Not found
  return UNKNOWN;

  
}

void freeData()
{
	int i = 0;
	int size;

	//All States
	for(i; i < NUMBER_OF_STATES; i++){
		size = listOfState[i].numberOfCityOrTown;
		if(size > 0){
			int s = 0;

			//All cities for each state
			for(s; s < size; s++){
				free(listOfCityOrTownByState[i][s].cityOrTownName);
			}

			free(listOfState[i].stateAbbreviation);
			free(listOfState[i].stateName);
		}
	}

}

char * getStateName(int index)
{
	return NULL;
}

// airList_place copy_node(airList_place head)
// {
// 	airList_place temp_head, walker;
// 	while(head->next)
// 	{
// 		if(!temp_head)
// 		{
// 			temp_head = malloc(sizeof(airNode_air));

// 			temp_head->next = NULL;

// 			temp_head->p.code = head->p.code;
// 			temp_head->p.name = head->p.name;

// 			temp_head->p.dist = head->p.dist;

// 			temp_head->p.loc.latitude = head->p.loc.latitude;
// 			temp_head->p.loc.longitude = head->p.loc.longitude;

// 			// Keeping track of the tail
// 			walker = temp_head;
// 		}
// 		else
// 		{
// 			airList_air temp = malloc(sizeof(airNode_air));

// 			temp->next = NULL;
// 			temp->p.code = head->p.code;
// 			temp->p.name = head->p.name;

// 			temp->p.dist = head->p.dist;
// 			temp->p.loc.latitude = head->p.loc.latitude;
// 			temp->p.loc.longitude = head->p.loc.longitude;

// 			walker->next = temp;
// 			walker = temp;
// 		}
// 	}

// 	return temp_head;
// }
